//! A module containing the information for Piece-Square Tables (PSTs). A PST
//! is given for both the early and endgame.

use fiddler_base::{
    movegen::NominateMove, Board, Color, Eval, Move, Piece, Position, Score, Square,
};

use crate::evaluate::blend_eval;

/// A lookup table for piece values. The outer index is the type of the piece
/// (in order of Pawn, Knight, Bishop, Rook, Queen, and King)
/// and the inner index is the square of the piece (from White's point of view)
/// , starting with A1 as the first index, then continuing on to B1, C1, and so
/// on until H8 as index 63.
type Pst = [[Score; 64]; Piece::NUM_TYPES];

/// A PST which is given in millipawns.
type CentiPst = [[(i16, i16); 64]; Piece::NUM_TYPES];

/// Evaluate a board based on its PST value. This is slow, so under most
/// conditions it is recommended to use `pst_delta()` instead if you are making
/// moves. The first value in the return type is the midgame difference, and
/// the second is the endgame difference.
pub fn pst_evaluate(board: &Board) -> Score {
    let mut score = (Eval::DRAW, Eval::DRAW);

    for pt in Piece::ALL_TYPES {
        for sq in board[pt] & board[Color::White] {
            score.0 += PST[pt as usize][sq as usize].0;
            score.1 += PST[pt as usize][sq as usize].1;
        }
        for sq in board[pt] & board[Color::Black] {
            //Invert the square that Black is on, since positional values are
            //flipped (as pawns move the other way, etc)
            let alt_sq = sq.opposite();

            score.0 -= PST[pt as usize][alt_sq as usize].0;
            score.1 -= PST[pt as usize][alt_sq as usize].1;
        }
    }

    score
}

/// Get the difference in PST value which would be generated by making the move
/// `m` on `board`. The first value in the return tuple is the midgame
/// difference, and the second is the endgame difference. `pst_delta` will
/// reflect how the position improves for the player making the move,
/// independed of if the player is white or black.
///
/// # Panics
///
/// `pst_delta` will panic if the given move is invalid.
pub fn pst_delta(board: &Board, m: Move) -> Score {
    let from_sq = m.from_square();
    let to_sq = m.to_square();
    let mover_type = board.type_at_square(m.from_square()).unwrap();
    let mover_idx = mover_type as usize;
    let end_type = match m.promote_type() {
        Some(pt) => pt,
        None => mover_type,
    };
    let end_idx = end_type as usize;
    let (from_alt, to_alt) = match board.player_to_move {
        Color::White => (from_sq, to_sq),
        Color::Black => (from_sq.opposite(), to_sq.opposite()),
    };
    let (from_idx, to_idx) = (from_alt as usize, to_alt as usize);

    // you always lose the value of the square you moved from
    let mut delta = (
        PST[end_idx][to_idx].0 - PST[mover_idx][from_idx].0,
        PST[end_idx][to_idx].1 - PST[mover_idx][from_idx].1,
    );

    if board[!board.player_to_move].contains(m.to_square()) {
        // conventional capture
        let to_opposite_idx = to_alt.opposite() as usize;
        let capturee_idx = board.type_at_square(to_sq).unwrap() as usize;
        delta.0 += PST[capturee_idx][to_opposite_idx].0;
        delta.1 += PST[capturee_idx][to_opposite_idx].1;
    }

    if m.is_en_passant() {
        let to_opposite_idx = (to_alt - Color::White.pawn_direction()).opposite() as usize;
        delta.0 += PST[Piece::Pawn as usize][to_opposite_idx].0;
        delta.1 += PST[Piece::Pawn as usize][to_opposite_idx].1;
    }

    if m.is_castle() {
        let is_queen_castle = to_sq.file() == 2;
        let (rook_from_idx, rook_to_idx) = match is_queen_castle {
            true => (Square::A1 as usize, Square::D1 as usize),
            false => (Square::H1 as usize, Square::F1 as usize),
        };

        delta.0 += PST[Piece::Rook as usize][rook_to_idx].0 
            - PST[Piece::Rook as usize][rook_from_idx].0;
        delta.1 += PST[Piece::Rook as usize][rook_to_idx].1 
            - PST[Piece::Rook as usize][rook_from_idx].1;
    }

    delta
}

pub struct PstNominate {}

impl NominateMove for PstNominate {
    type Output = (Score, Eval);

    #[inline(always)]
    fn score(m: Move, pos: &Position) -> Self::Output {
        let delta = pst_delta(&pos.board, m);
        (delta, blend_eval(&pos.board, delta.0, delta.1))
    }
}

/// A function used for ergonomics to convert from a table of millipawn values
/// to a table of `Eval`s.
const fn expand_table(centi_table: CentiPst) -> Pst {
    let mut table = [[(Eval::DRAW, Eval::DRAW); 64]; Piece::NUM_TYPES];
    let mut piece_idx = 0;
    // I would use for-loops here, but those are unsupported in const fns.
    while piece_idx < Piece::NUM_TYPES {
        let mut sq_idx = 0;
        while sq_idx < 64 {
            let int_score = centi_table[piece_idx][sq_idx];
            table[piece_idx][sq_idx] = (
                Eval::centipawns(int_score.0), 
                Eval::centipawns(int_score.1)
            );
            sq_idx += 1;
        }
        piece_idx += 1;
    }
    table
}

#[rustfmt::skip] // rustfmt likes to throw a million newlines in this
/// The main piece-square table. Evaluations are paired together as (midgame, 
/// endgame) to improve cache-friendliness. The indexing order of this table 
/// has its primary index as pieces, the secondary index as squares, and the 
/// innermost index as 0 for midgame and 1 for endgame.
pub const PST: Pst = expand_table([
    [ // N
        (-90, -52), (-40, -33), (-62, -29), (-66, -21), (-60, -29), (-63, -28), (-52, -32), (-54, -37),
        (-79, -30), (-42, -18), (-31, 4), (-16, 0), (-27, 0), (-15, 2), (-28, -10), (-57, -35),
        (-56, -29), (-22, 7), (24, 3), (2, 8), (5, 14), (20, 9), (-8, 3), (-62, -32),
        (-28, -32), (-5, 5), (16, 21), (9, 19), (20, 18), (-1, 17), (-1, -2), (-27, -33),
        (-6, -28), (15, 1), (44, 13), (64, 23), (47, 18), (71, 23), (-1, -1), (13, -25),
        (-7, -26), (26, 5), (25, 17), (65, 6), (64, 17), (16, 10), (44, -5), (13, -23),
        (-16, -36), (-5, -23), (70, -2), (-13, 0), (22, 3), (48, -2), (-3, -16), (-12, -35),
        (-71, -47), (-46, -41), (-39, -28), (-38, -31), (-28, -35), (-46, -27), (-37, -38), (-62, -39),
    ],
    [ // B
        (-51, -24), (-41, -6), (-10, -17), (-74, -10), (-62, -5), (-22, -9), (-18, -2), (-42, -19),
        (-37, -4), (2, 3), (-16, 1), (-21, -3), (-15, 3), (-27, 6), (16, 9), (-29, -15),
        (-21, -11), (-12, 3), (-11, 10), (18, 4), (19, 0), (-29, 11), (1, 15), (-28, -8),
        (-29, -9), (-4, -2), (13, 16), (19, 10), (11, 8), (14, 12), (-11, 3), (-18, -9),
        (5, -9), (10, 0), (31, 6), (38, 8), (36, 7), (32, 5), (2, 8), (3, -11),
        (1, -9), (13, -1), (-25, 0), (28, 13), (20, 2), (-46, 0), (52, 0), (19, -7),
        (-4, -10), (20, -1), (13, -3), (-47, 5), (-44, 0), (17, 4), (6, 2), (18, -10),
        (-27, -17), (-14, 0), (-17, -7), (-20, -8), (-22, -8), (-40, -8), (-19, -9), (-13, -14),
    ],
    [ // R
        (-35, 8), (-53, 5), (-30, 3), (-12, -4), (-20, 2), (-15, -2), (-37, -4), (-51, 2),
        (-50, -3), (-43, 3), (-44, -1), (-45, 2), (-49, 3), (-32, -2), (-25, 6), (-33, -1),
        (-41, -4), (-35, -1), (-26, -4), (-36, -8), (-34, -3), (-43, 0), (-24, 0), (-41, -8),
        (-10, -1), (-5, 4), (1, 0), (0, -3), (-4, 0), (-15, -3), (-17, 1), (-24, -5),
        (10, 2), (2, 0), (22, 2), (22, -5), (16, 3), (18, 0), (16, -4), (11, -7),
        (23, -11), (23, 2), (33, 0), (38, -6), (36, -6), (36, -8), (39, -5), (33, -5),
        (27, 1), (23, 13), (32, 12), (24, 3), (27, 14), (50, 6), (43, 12), (48, 6),
        (-20, -4), (-12, 0), (-9, -7), (-21, -8), (-13, -3), (-26, 0), (-10, -2), (4, 0),
    ],
    [ // Q
        (-37, -15), (-69, -10), (-64, -4), (-1, -6), (-58, -3), (-62, -6), (-14, -2), (-23, -18),
        (-60, -12), (-54, 0), (-18, 9), (-19, 0), (-25, 1), (-14, -2), (-8, 0), (-6, -7),
        (-37, -9), (-18, 9), (-15, 1), (-19, 4), (-18, 3), (-9, 0), (-12, 1), (-20, -4),
        (-19, -4), (-15, 4), (-2, 9), (33, 5), (20, 9), (-8, 2), (-8, 0), (-6, 4),
        (-7, -8), (0, 0), (28, -2), (45, 6), (46, 0), (46, -3), (17, 0), (35, -3),
        (1, -12), (9, 1), (46, 7), (50, 1), (75, 4), (81, 10), (111, 0), (67, -5),
        (13, -10), (14, 5), (19, 3), (2, -1), (16, -7), (91, 4), (65, -4), (85, -15),
        (-16, -23), (-3, -9), (-3, -11), (-10, -6), (8, -7), (5, -10), (5, -8), (16, -23),
    ],
    [ // P
        (-5, -3), (0, -7), (2, 4), (-2, -2), (1, -6), (4, -7), (-5, 6), (-2, 1),
        (3, 9), (34, 13), (7, 11), (-21, -18), (10, -16), (52, 13), (46, 9), (7, 0),
        (-10, 11), (4, -5), (7, -8), (11, 0), (28, 9), (-8, -8), (9, -12), (-10, 4),
        (-11, 1), (11, -1), (14, -2), (48, 11), (43, 12), (-3, 2), (-5, -2), (-18, -2),
        (20, 0), (31, 6), (41, 15), (44, 19), (46, 28), (37, 6), (18, 0), (11, 9),
        (80, 14), (94, 10), (86, 17), (102, 23), (100, 30), (79, 19), (102, 11), (66, 12),
        (127, 54), (125, 41), (131, 47), (112, 45), (104, 50), (133, 53), (124, 49), (113, 52),
        (3, -3), (-4, 0), (2, -3), (7, 1), (0, -5), (-1, 4), (7, 5), (8, 1),
    ],
    [ // K
        (-53, -46), (-3, -35), (13, -34), (-92, -24), (-14, -34), (-86, -33), (28, -28), (-63, -42),
        (-43, -32), (-37, -33), (-65, -4), (-72, 3), (-70, 0), (-42, -2), (-24, -24), (-43, -32),
        (-43, -36), (-57, -8), (-58, 16), (-61, 29), (-50, 35), (-55, 19), (-49, -16), (-73, -32),
        (-21, -35), (-21, -7), (-21, 27), (-21, 39), (-20, 45), (-22, 24), (-21, -16), (-39, -27),
        (-23, -28), (-5, -2), (4, 24), (-3, 41), (0, 41), (15, 31), (17, -6), (-9, -28),
        (-26, -31), (-3, -7), (-9, 25), (-16, 33), (-17, 33), (8, 17), (20, -5), (-6, -27),
        (-25, -26), (-19, -18), (-11, -17), (-25, 0), (-20, -2), (-8, -7), (8, -11), (-3, -29),
        (-29, -57), (-38, -45), (-35, -24), (-51, -16), (-46, -18), (-28, 1), (0, -44), (-20, -42),
    ],
]);

#[cfg(test)]
mod tests {

    use super::*;
    use fiddler_base::movegen::{get_moves, NoopNominator};
    use fiddler_base::Position;

    #[test]
    /// Test that adding deltas matches the same result as taking the PST value
    /// from scratch.
    fn test_pst_delta_equals_base_result() {
        let pos = Position::from_fen(
            "r1bq1b1r/ppp2kpp/2n5/3np3/2B5/8/PPPP1PPP/RNBQK2R w KQ - 0 7",
            Position::no_eval,
        )
        .unwrap();
        let pst_original = pst_evaluate(&pos.board);

        for m in get_moves::<NoopNominator>(&pos) {
            let delta = pst_delta(&pos.board, m.0);
            let delta_eval = (pst_original.0 + delta.0, pst_original.1 + delta.1);
            let mut bcopy = pos.board;
            bcopy.make_move(m.0);
            assert_eq!(delta_eval, pst_evaluate(&bcopy));
        }
    }
}
