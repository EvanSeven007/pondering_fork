//! A module containing the information for Piece-Square Tables (PSTs). A PST
//! is given for both the early and endgame.

use fiddler_base::{
    movegen::NominateMove, Board, Color, Eval, Move, Piece, Position, Score, Square,
};

use crate::evaluate::blend_eval;

/// A lookup table for piece values. The outer index is the type of the piece
/// (in order of Pawn, Knight, Bishop, Rook, Queen, and King)
/// and the inner index is the square of the piece (from White's point of view)
/// , starting with A1 as the first index, then continuing on to B1, C1, and so
/// on until H8 as index 63.
type Pst = [[Score; 64]; Piece::NUM_TYPES];

/// A PST which is given in millipawns.
type CentiPst = [[(i16, i16); 64]; Piece::NUM_TYPES];

/// Evaluate a board based on its PST value. This is slow, so under most
/// conditions it is recommended to use `pst_delta()` instead if you are making
/// moves. The first value in the return type is the midgame difference, and
/// the second is the endgame difference.
pub fn pst_evaluate(board: &Board) -> Score {
    let mut score = (Eval::DRAW, Eval::DRAW);

    for pt in Piece::ALL_TYPES {
        for sq in board[pt] & board[Color::White] {
            score.0 += PST[pt as usize][sq as usize].0;
            score.1 += PST[pt as usize][sq as usize].1;
        }
        for sq in board[pt] & board[Color::Black] {
            //Invert the square that Black is on, since positional values are
            //flipped (as pawns move the other way, etc)
            let alt_sq = sq.opposite();

            score.0 -= PST[pt as usize][alt_sq as usize].0;
            score.1 -= PST[pt as usize][alt_sq as usize].1;
        }
    }

    score
}

/// Get the difference in PST value which would be generated by making the move
/// `m` on `board`. The first value in the return tuple is the midgame
/// difference, and the second is the endgame difference. `pst_delta` will
/// reflect how the position improves for the player making the move,
/// independed of if the player is white or black.
///
/// # Panics
///
/// `pst_delta` will panic if the given move is invalid.
pub fn pst_delta(board: &Board, m: Move) -> Score {
    let from_sq = m.from_square();
    let to_sq = m.to_square();
    let mover_type = board.type_at_square(m.from_square()).unwrap();
    let mover_idx = mover_type as usize;
    let end_type = match m.promote_type() {
        Some(pt) => pt,
        None => mover_type,
    };
    let end_idx = end_type as usize;
    let (from_alt, to_alt) = match board.player_to_move {
        Color::White => (from_sq, to_sq),
        Color::Black => (from_sq.opposite(), to_sq.opposite()),
    };
    let (from_idx, to_idx) = (from_alt as usize, to_alt as usize);

    // you always lose the value of the square you moved from
    let mut delta = (
        PST[end_idx][to_idx].0 - PST[mover_idx][from_idx].0,
        PST[end_idx][to_idx].1 - PST[mover_idx][from_idx].1,
    );

    if board[!board.player_to_move].contains(m.to_square()) {
        // conventional capture
        let to_opposite_idx = to_alt.opposite() as usize;
        let capturee_idx = board.type_at_square(to_sq).unwrap() as usize;
        delta.0 += PST[capturee_idx][to_opposite_idx].0;
        delta.1 += PST[capturee_idx][to_opposite_idx].1;
    }

    if m.is_en_passant() {
        let to_opposite_idx = (to_alt - Color::White.pawn_direction()).opposite() as usize;
        delta.0 += PST[Piece::Pawn as usize][to_opposite_idx].0;
        delta.1 += PST[Piece::Pawn as usize][to_opposite_idx].1;
    }

    if m.is_castle() {
        let is_queen_castle = to_sq.file() == 2;
        let (rook_from_idx, rook_to_idx) = match is_queen_castle {
            true => (Square::A1 as usize, Square::D1 as usize),
            false => (Square::H1 as usize, Square::F1 as usize),
        };

        delta.0 +=
            PST[Piece::Rook as usize][rook_to_idx].0 - PST[Piece::Rook as usize][rook_from_idx].0;
        delta.1 +=
            PST[Piece::Rook as usize][rook_to_idx].1 - PST[Piece::Rook as usize][rook_from_idx].1;
    }

    delta
}

pub struct PstNominate {}

impl NominateMove for PstNominate {
    type Output = (Score, Eval);

    #[inline(always)]
    fn score(m: Move, pos: &Position) -> Self::Output {
        let delta = pst_delta(&pos.board, m);
        (delta, blend_eval(&pos.board, delta.0, delta.1))
    }
}

/// A function used for ergonomics to convert from a table of millipawn values
/// to a table of `Eval`s.
const fn expand_table(centi_table: CentiPst) -> Pst {
    let mut table = [[(Eval::DRAW, Eval::DRAW); 64]; Piece::NUM_TYPES];
    let mut piece_idx = 0;
    // I would use for-loops here, but those are unsupported in const fns.
    while piece_idx < Piece::NUM_TYPES {
        let mut sq_idx = 0;
        while sq_idx < 64 {
            let int_score = centi_table[piece_idx][sq_idx];
            table[piece_idx][sq_idx] =
                (Eval::centipawns(int_score.0), Eval::centipawns(int_score.1));
            sq_idx += 1;
        }
        piece_idx += 1;
    }
    table
}

#[rustfmt::skip] // rustfmt likes to throw a million newlines in this
/// The main piece-square table. Evaluations are paired together as (midgame, 
/// endgame) to improve cache-friendliness. The indexing order of this table 
/// has its primary index as pieces, the secondary index as squares, and the 
/// innermost index as 0 for midgame and 1 for endgame.
pub const PST: Pst = expand_table([
    [ // N
        (-91, -54), (-35, -33), (-62, -26), (-63, -19), (-53, -28), (-64, -23), (-40, -30), (-51, -33), 
        (-82, -34), (-43, -18), (-30, 5), (-3, -1), (-12, -2), (-21, 4), (-26, -12), (-52, -39),
        (-50, -29), (-13, 11), (33, 7), (5, 6), (9, 13), (36, 13), (0, 1), (-59, -34),
        (-24, -28), (-9, 3), (15, 25), (12, 20), (18, 18), (3, 16), (-2, -5), (-18, -30),
        (-5, -25), (16, 3), (43, 13), (63, 19), (44, 14), (70, 18), (8, -4), (12, -25),
        (-4, -28), (24, 0), (17, 12), (63, 6), (62, 16), (8, 5), (47, -7), (14, -25),
        (-12, -37), (-5, -27), (67, -5), (-15, 2), (24, 0), (48, -2), (-1, -14), (-13, -31),
        (-68, -46), (-49, -40), (-40, -27), (-38, -28), (-26, -30), (-42, -28), (-39, -34), (-68, -38),
    ],
    [ // B
        (-47, -24), (-34, -2), (-7, -17), (-67, -8), (-58, -2), (-14, -9), (-21, -2), (-45, -15),
        (-35, -1), (2, 0), (-5, 0), (-9, 0), (-1, 4), (-26, 1), (20, 9), (-26, -15),
        (-15, -12), (3, 7), (-7, 8), (35, 2), (28, 0), (-21, 15), (9, 18), (-27, -10),
        (-25, -4), (-4, -1), (28, 15), (13, 11), (6, 8), (22, 12), (-9, -1), (-11, -6),
        (7, -10), (11, 0), (30, 5), (31, 6), (29, 11), (33, 9), (7, 9), (4, -14),
        (-4, -5), (13, 3), (-33, -4), (29, 14), (15, 0), (-51, 1), (52, 0), (21, -4),
        (-10, -5), (12, 3), (13, 0), (-52, 7), (-49, 0), (11, 1), (6, 6), (15, -14),
        (-22, -12), (-13, 3), (-19, -10), (-17, -3), (-25, -10), (-44, -4), (-21, -12), (-9, -14),
    ],
    [ // R
        (-38, 8), (-24, 0), (-9, 0), (4, -1), (-3, 6), (-6, -3), (-15, -5), (-47, 5),
        (-49, 0), (-41, 3), (-40, -4), (-35, 0), (-40, 0), (-32, 0), (-26, 10), (-33, -1),
        (-37, -7), (-31, 1), (-24, 0), (-27, -11), (-32, -3), (-36, -4), (-20, -3), (-34, -5),
        (-12, 2), (-4, 2), (-2, 0), (-1, -1), (-7, -2), (-12, -7), (-19, -2), (-21, -9),
        (11, 1), (4, 0), (19, 5), (21, -2), (11, 6), (18, 3), (17, -6), (7, -9),
        (18, -9), (22, 2), (35, -1), (36, -5), (28, -10), (37, -11), (38, 0), (36, -4),
        (24, 5), (29, 8), (36, 8), (34, 1), (30, 15), (51, 5), (45, 9), (51, 7),
        (-18, -6), (-10, 3), (-6, -5), (-14, -8), (-10, -4), (-27, -4), (-9, -2), (4, -1),
    ],
    [ // Q
        (-38, -10), (-66, -5), (-58, -7), (11, -4), (-54, -3), (-58, -5), (-13, 0), (-23, -20),
        (-69, -12), (-61, -4), (-8, 10), (-5, 4), (-10, -2), (-15, -4), (-12, 4), (-8, -6),
        (-34, -5), (-7, 4), (-12, 4), (-7, 0), (-10, 3), (5, 1), (-7, 0), (-21, -4),
        (-14, -5), (-17, 8), (-3, 8), (29, 8), (13, 10), (-3, -1), (-2, 4), (1, 6),
        (-5, -6), (0, -2), (20, -3), (41, 2), (45, 1), (46, 0), (21, 0), (40, -3),
        (1, -10), (12, 1), (42, 10), (49, 5), (72, 2), (84, 13), (115, -1), (67, -4),
        (9, -9), (7, 5), (17, 3), (7, -3), (15, -6), (97, 0), (69, -3), (88, -18),
        (-17, -21), (-1, -13), (-2, -14), (-11, -2), (12, -2), (8, -9), (3, -12), (16, -20),
    ],
    [ // P
        (0, 0), (0, -10), (3, 4), (-2, -1), (-3, -9), (7, -11), (-5, 4), (-2, 5),
        (-4, 8), (14, 9), (-3, 14), (-38, -22), (0, -19), (31, 15), (34, 5), (-3, 3),
        (-9, 15), (-4, -4), (0, -4), (-8, 2), (5, 6), (-10, -10), (7, -7), (-10, 8),
        (-10, 3), (0, -5), (9, 0), (32, 12), (26, 8), (-4, -2), (-8, 1), (-14, -5),
        (16, 4), (17, 4), (19, 11), (25, 22), (31, 27), (24, 6), (15, -4), (13, 5),
        (68, 12), (86, 14), (64, 17), (82, 19), (79, 34), (68, 23), (90, 13), (58, 15),
        (105, 53), (100, 38), (121, 46), (114, 49), (106, 48), (117, 50), (112, 45), (96, 51),
        (1, -2), (-8, -1), (3, -3), (10, 3), (-3, -9), (-4, 0), (8, 2), (10, -3),
    ],
    [ // K
        (-50, -42), (8, -37), (17, -30), (-80, -22), (-13, -37), (-72, -33), (32, -29), (-36, -45),
        (-44, -27), (-38, -30), (-53, -8), (-57, 4), (-51, -2), (-35, -6), (-16, -23), (-38, -29),
        (-40, -39), (-57, -8), (-52, 19), (-49, 30), (-42, 37), (-45, 15), (-43, -18), (-73, -30),
        (-21, -32), (-22, -5), (-21, 28), (-17, 40), (-19, 48), (-18, 21), (-26, -13), (-45, -24),
        (-27, -32), (-5, -3), (0, 19), (-6, 44), (0, 36), (15, 35), (16, -2), (-10, -29),
        (-28, -28), (0, -8), (-6, 27), (-10, 34), (-12, 30), (7, 13), (20, -5), (-9, -23),
        (-23, -25), (-22, -16), (-6, -12), (-19, 2), (-15, 0), (-10, -9), (9, -15), (2, -25),
        (-30, -55), (-39, -47), (-30, -24), (-46, -20), (-42, -22), (-31, 1), (0, -42), (-18, -42),
    ],
]);

#[cfg(test)]
mod tests {

    use super::*;
    use fiddler_base::movegen::{get_moves, NoopNominator};
    use fiddler_base::Position;

    #[test]
    /// Test that adding deltas matches the same result as taking the PST value
    /// from scratch.
    fn test_pst_delta_equals_base_result() {
        let pos = Position::from_fen(
            "r1bq1b1r/ppp2kpp/2n5/3np3/2B5/8/PPPP1PPP/RNBQK2R w KQ - 0 7",
            Position::no_eval,
        )
        .unwrap();
        let pst_original = pst_evaluate(&pos.board);

        for m in get_moves::<NoopNominator>(&pos) {
            let delta = pst_delta(&pos.board, m.0);
            let delta_eval = (pst_original.0 + delta.0, pst_original.1 + delta.1);
            let mut bcopy = pos.board;
            bcopy.make_move(m.0);
            assert_eq!(delta_eval, pst_evaluate(&bcopy));
        }
    }
}
