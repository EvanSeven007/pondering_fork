//! A module containing the information for Piece-Square Tables (PSTs). A PST
//! is given for both the early and endgame.

use fiddler_base::{
    movegen::NominateMove, Board, Color, Eval, Move, Piece, Position, Score, Square,
};

use crate::evaluate::blend_eval;

/// A lookup table for piece values. The outer index is the type of the piece
/// (in order of Pawn, Knight, Bishop, Rook, Queen, and King)
/// and the inner index is the square of the piece (from White's point of view)
/// , starting with A1 as the first index, then continuing on to B1, C1, and so
/// on until H8 as index 63.
type Pst = [[Score; 64]; Piece::NUM_TYPES];

/// A PST which is given in millipawns.
type CentiPst = [[(i16, i16); 64]; Piece::NUM_TYPES];

/// Evaluate a board based on its PST value. This is slow, so under most
/// conditions it is recommended to use `pst_delta()` instead if you are making
/// moves. The first value in the return type is the midgame difference, and
/// the second is the endgame difference.
pub fn pst_evaluate(board: &Board) -> Score {
    let mut score = (Eval::DRAW, Eval::DRAW);

    for pt in Piece::ALL_TYPES {
        for sq in board[pt] & board[Color::White] {
            score.0 += PST[pt as usize][sq as usize].0;
            score.1 += PST[pt as usize][sq as usize].1;
        }
        for sq in board[pt] & board[Color::Black] {
            //Invert the square that Black is on, since positional values are
            //flipped (as pawns move the other way, etc)
            let alt_sq = sq.opposite();

            score.0 -= PST[pt as usize][alt_sq as usize].0;
            score.1 -= PST[pt as usize][alt_sq as usize].1;
        }
    }

    score
}

/// Get the difference in PST value which would be generated by making the move
/// `m` on `board`. The first value in the return tuple is the midgame
/// difference, and the second is the endgame difference. `pst_delta` will
/// reflect how the position improves for the player making the move,
/// independed of if the player is white or black.
///
/// # Panics
///
/// `pst_delta` will panic if the given move is invalid.
pub fn pst_delta(board: &Board, m: Move) -> Score {
    let from_sq = m.from_square();
    let to_sq = m.to_square();
    let mover_type = board.type_at_square(m.from_square()).unwrap();
    let mover_idx = mover_type as usize;
    let end_type = match m.promote_type() {
        Some(pt) => pt,
        None => mover_type,
    };
    let end_idx = end_type as usize;
    let (from_alt, to_alt) = match board.player_to_move {
        Color::White => (from_sq, to_sq),
        Color::Black => (from_sq.opposite(), to_sq.opposite()),
    };
    let (from_idx, to_idx) = (from_alt as usize, to_alt as usize);

    // you always lose the value of the square you moved from
    let mut delta = (
        PST[end_idx][to_idx].0 - PST[mover_idx][from_idx].0,
        PST[end_idx][to_idx].1 - PST[mover_idx][from_idx].1,
    );

    if board[!board.player_to_move].contains(m.to_square()) {
        // conventional capture
        let to_opposite_idx = to_alt.opposite() as usize;
        let capturee_idx = board.type_at_square(to_sq).unwrap() as usize;
        delta.0 += PST[capturee_idx][to_opposite_idx].0;
        delta.1 += PST[capturee_idx][to_opposite_idx].1;
    }

    if m.is_en_passant() {
        let to_opposite_idx = (to_alt - Color::White.pawn_direction()).opposite() as usize;
        delta.0 += PST[Piece::Pawn as usize][to_opposite_idx].0;
        delta.1 += PST[Piece::Pawn as usize][to_opposite_idx].1;
    }

    if m.is_castle() {
        let is_queen_castle = to_sq.file() == 2;
        let (rook_from_idx, rook_to_idx) = match is_queen_castle {
            true => (Square::A1 as usize, Square::D1 as usize),
            false => (Square::H1 as usize, Square::F1 as usize),
        };

        delta.0 +=
            PST[Piece::Rook as usize][rook_to_idx].0 - PST[Piece::Rook as usize][rook_from_idx].0;
        delta.1 +=
            PST[Piece::Rook as usize][rook_to_idx].1 - PST[Piece::Rook as usize][rook_from_idx].1;
    }

    delta
}

pub struct PstNominate {}

impl NominateMove for PstNominate {
    type Output = (Score, Eval);

    #[inline(always)]
    fn score(m: Move, pos: &Position) -> Self::Output {
        let delta = pst_delta(&pos.board, m);
        (delta, blend_eval(&pos.board, delta.0, delta.1))
    }
}

/// A function used for ergonomics to convert from a table of millipawn values
/// to a table of `Eval`s.
const fn expand_table(centi_table: CentiPst) -> Pst {
    let mut table = [[(Eval::DRAW, Eval::DRAW); 64]; Piece::NUM_TYPES];
    let mut piece_idx = 0;
    // I would use for-loops here, but those are unsupported in const fns.
    while piece_idx < Piece::NUM_TYPES {
        let mut sq_idx = 0;
        while sq_idx < 64 {
            let int_score = centi_table[piece_idx][sq_idx];
            table[piece_idx][sq_idx] =
                (Eval::centipawns(int_score.0), Eval::centipawns(int_score.1));
            sq_idx += 1;
        }
        piece_idx += 1;
    }
    table
}

#[rustfmt::skip] // rustfmt likes to throw a million newlines in this
/// The main piece-square table. Evaluations are paired together as (midgame, 
/// endgame) to improve cache-friendliness. The indexing order of this table 
/// has its primary index as pieces, the secondary index as squares, and the 
/// innermost index as 0 for midgame and 1 for endgame.
pub const PST: Pst = expand_table([
    [ // N
        (-166, -54), (-34, -27), (-72, -19), (-54, -22), (-47, -32), (-51, -32), (-36, -24), (-87, -29),
        (-94, -24), (-62, -10), (-19, -1), (-4, 5), (-9, 0), (-22, -1), (-38, -5), (-41, -40),
        (-47, -23), (-9, 16), (33, 2), (11, 4), (15, 1), (37, 15), (7, 0), (-46, -31),
        (-18, -31), (-18, 1), (17, 20), (10, 20), (16, 6), (9, 10), (0, -1), (-14, -26),
        (0, -29), (16, 0), (39, 8), (59, 27), (41, 19), (74, 20), (12, -3), (30, -31),
        (-15, -28), (34, 2), (-11, 10), (70, 2), (58, 7), (-14, 0), (48, -7), (24, -25),
        (-35, -39), (-19, -32), (68, -4), (-14, 1), (31, -1), (32, -10), (-1, -17), (-10, -31),
        (-89, -46), (-57, -48), (-52, -21), (-44, -25), (-18, -28), (-80, -30), (-41, -35), (-105, -35),
    ],
    [ // B
        (-56, -22), (-18, 5), (-7, -18), (-57, -4), (-59, -2), (-11, -14), (-37, -10), (-59, -11),
        (-26, 0), (4, -3), (2, -5), (-9, -1), (-1, 6), (-24, 3), (23, 12), (-21, -1),
        (-4, -8), (5, 11), (-2, 13), (34, 3), (29, -7), (-11, 19), (12, 18), (-14, 3),
        (-19, -5), (-14, -7), (28, 14), (7, 9), (2, 6), (22, 5), (-11, -7), (-7, -6),
        (3, -3), (12, -3), (16, 13), (25, 4), (23, 15), (18, 10), (6, 10), (7, -9),
        (-10, -6), (12, 7), (-55, 2), (25, 9), (2, -3), (-82, -8), (43, -5), (25, -3),
        (-37, -1), (-5, 12), (-3, 4), (-113, 6), (-88, -3), (-12, 0), (-33, -1), (0, -12),
        (-31, -11), (-35, -1), (-44, 2), (-51, 1), (-23, -12), (-100, -4), (-38, -14), (-11, -17),
    ],
    [ // R
        (-22, 16), (-25, 4), (-17, 2), (-11, -1), (-20, 5), (2, -4), (-10, -4), (-44, 6),
        (-44, -10), (-36, 7), (-30, -2), (-32, -3), (-35, 0), (-26, -1), (-20, 9), (-29, -3),
        (-32, -4), (-18, 0), (-20, -2), (-28, -14), (-29, -6), (-23, -4), (-13, -1), (-27, -7),
        (-10, 0), (-16, 7), (-12, -4), (-19, 1), (-23, -3), (-22, -1), (-23, 1), (-22, -10),
        (-5, 2), (-10, 3), (5, 8), (-2, 0), (-6, -2), (2, 1), (1, -13), (-2, -2),
        (6, -9), (15, -1), (17, -5), (17, -7), (6, -12), (25, -15), (32, -7), (20, -4),
        (14, 2), (23, 6), (36, 0), (36, 1), (35, 11), (44, -1), (42, 13), (35, 6),
        (-4, -9), (18, 4), (16, -7), (0, -10), (1, -7), (-19, 0), (14, 0), (24, 5),
    ],
    [ // Q
        (-37, -8), (-56, -10), (-48, 2), (10, -5), (-37, -9), (-59, -5), (-14, -1), (-27, -16),
        (-111, -5), (-64, 1), (-8, 10), (-7, -6), (-10, -8), (-11, -1), (-10, -2), (-4, -6),
        (-45, -11), (-3, 0), (-6, 5), (-5, 0), (-8, 8), (8, 3), (0, 6), (-10, -1),
        (-9, -9), (-24, 7), (-4, 3), (26, 5), (10, 11), (-1, -4), (5, 4), (7, 11),
        (-18, 2), (-9, -2), (4, 2), (29, 0), (31, -6), (36, -3), (20, -9), (45, -1),
        (-22, -15), (0, 4), (22, 3), (38, 3), (62, 11), (94, 15), (116, -3), (73, -12),
        (-30, -9), (-17, -4), (6, 1), (20, -10), (33, -15), (109, 7), (68, 0), (96, -21),
        (-7, -14), (9, -11), (24, -6), (12, 1), (53, 0), (50, -3), (42, -3), (53, -21),
    ],
    [ // P
        (-1, -6), (-8, -14), (-5, 4), (-4, -10), (-3, -6), (12, -13), (0, 4), (-6, 0),
        (-7, 10), (11, 5), (-6, 10), (-41, -8), (-2, -15), (29, 14), (32, 8), (-5, 5),
        (-11, 8), (-6, -2), (-2, 0), (-12, 6), (2, 3), (-13, -13), (6, -8), (-11, 13),
        (-10, 1), (0, -5), (8, -1), (30, 13), (25, 14), (-5, -2), (-9, 4), (-16, -1),
        (9, 1), (15, 8), (14, 9), (22, 22), (27, 21), (16, 9), (11, -2), (4, 10),
        (40, 10), (52, 11), (31, 19), (57, 17), (51, 25), (47, 20), (54, 21), (41, 7),
        (63, 56), (61, 37), (71, 58), (103, 53), (87, 42), (75, 51), (66, 40), (43, 51),
        (6, 1), (-5, 2), (-1, 0), (16, 0), (-8, 0), (-2, 0), (3, 0), (10, -9),
    ],
    [ // K
        (-45, -44), (17, -35), (14, -23), (-62, -19), (-10, -38), (-57, -35), (29, -30), (-29, -49),
        (-45, -27), (-20, -31), (-29, -1), (-35, -2), (-33, 1), (-17, 1), (-6, -17), (-29, -20),
        (-49, -42), (-32, -4), (-22, 10), (-22, 26), (-16, 42), (-19, 17), (-22, -14), (-53, -30),
        (-40, -29), (-13, -6), (-3, 38), (2, 45), (0, 43), (-5, 26), (-18, -4), (-47, -18),
        (-23, -30), (10, 2), (22, 13), (18, 46), (22, 31), (20, 31), (14, -2), (-19, -26),
        (-23, -20), (28, -16), (27, 18), (25, 35), (21, 35), (41, 2), (38, -8), (1, -16),
        (-22, -26), (19, -20), (32, -1), (12, -1), (20, 7), (22, -8), (37, -18), (18, -17),
        (-35, -50), (-27, -48), (-21, -27), (-41, -12), (-35, -24), (-17, 3), (29, -42), (-12, -39),
    ],
]);

#[cfg(test)]
mod tests {

    use super::*;
    use fiddler_base::movegen::{get_moves, NoopNominator};
    use fiddler_base::Position;

    #[test]
    /// Test that adding deltas matches the same result as taking the PST value
    /// from scratch.
    fn test_pst_delta_equals_base_result() {
        let pos = Position::from_fen(
            "r1bq1b1r/ppp2kpp/2n5/3np3/2B5/8/PPPP1PPP/RNBQK2R w KQ - 0 7",
            Position::no_eval,
        )
        .unwrap();
        let pst_original = pst_evaluate(&pos.board);

        for m in get_moves::<NoopNominator>(&pos) {
            let delta = pst_delta(&pos.board, m.0);
            let delta_eval = (pst_original.0 + delta.0, pst_original.1 + delta.1);
            let mut bcopy = pos.board;
            bcopy.make_move(m.0);
            assert_eq!(delta_eval, pst_evaluate(&bcopy));
        }
    }
}
