//! A module containing the information for Piece-Square Tables (PSTs). A PST
//! is given for both the early and endgame.

use crate::base::{Board, Color, Eval, Move, Piece, Square};

/// A lookup table for piece values. The outer index is the type of the piece
/// (in order of Pawn, Knight, Bishop, Rook, Queen, and King)
/// and the inner index is the square of the piece (from White's point of view)
/// , starting with A1 as the first index, then continuing on to B1, C1, and so
/// on until H8 as index 63.
type Pst = [[Eval; 64]; Piece::NUM_TYPES];

/// A PST which is given in millipawns.
type CentiPst = [[i16; 64]; Piece::NUM_TYPES];

/// Evaluate a board based on its PST value. This is slow, so under most
/// conditions it is recommended to use `pst_delta()` instead if you are making
/// moves. The first value in the return type is the midgame difference, and
/// the second is the endgame difference.
pub fn pst_evaluate(board: &Board) -> (Eval, Eval) {
    let mut mg_eval = Eval::DRAW;
    let mut eg_eval = Eval::DRAW;

    for pt in Piece::ALL_TYPES {
        for sq in board[pt] & board[Color::White] {
            mg_eval += MIDGAME_VALUE[pt as usize][sq as usize];
            eg_eval += ENDGAME_VALUE[pt as usize][sq as usize];
        }
        for sq in board[pt] & board[Color::Black] {
            //Invert the square that Black is on, since positional values are
            //flipped (as pawns move the other way, etc)
            let alt_sq = sq.opposite();

            mg_eval -= MIDGAME_VALUE[pt as usize][alt_sq as usize];
            eg_eval -= ENDGAME_VALUE[pt as usize][alt_sq as usize];
        }
    }

    (mg_eval, eg_eval)
}

/// Get the difference in PST value which would be generated by making the move
/// `m` on `board`. The first value in the return tuple is the midgame
/// difference, and the second is the endgame difference. `pst_delta` will
/// reflect how the position improves for the player making the move,
/// independed of if the player is white or black.
///
/// # Panics
///
/// if the move given is invalid
pub fn pst_delta(board: &Board, m: Move) -> (Eval, Eval) {
    let from_sq = m.from_square();
    let to_sq = m.to_square();
    let mover_type = board.type_at_square(m.from_square()).unwrap();
    let mover_idx = mover_type as usize;
    let end_type = match m.promote_type() {
        Some(pt) => pt,
        None => mover_type,
    };
    let end_idx = end_type as usize;
    let (from_alt, to_alt) = match board.player_to_move {
        Color::White => (from_sq, to_sq),
        Color::Black => (from_sq.opposite(), to_sq.opposite()),
    };
    let (from_idx, to_idx) = (from_alt as usize, to_alt as usize);

    // you always lose the value of the square you moved from
    let mut mg_delta = MIDGAME_VALUE[end_idx][to_idx] - MIDGAME_VALUE[mover_idx][from_idx];
    let mut eg_delta =
        ENDGAME_VALUE[end_idx][to_idx] - ENDGAME_VALUE[mover_type as usize][from_idx];

    if board[!board.player_to_move].contains(m.to_square()) {
        // conventional capture
        let to_opposite_idx = to_alt.opposite() as usize;
        let capturee_idx = board.type_at_square(to_sq).unwrap() as usize;
        mg_delta += MIDGAME_VALUE[capturee_idx][to_opposite_idx];
        eg_delta += ENDGAME_VALUE[capturee_idx][to_opposite_idx];
    }

    if board.is_move_en_passant(m) {
        let to_opposite_idx = (to_alt - Color::White.pawn_direction()).opposite() as usize;

        mg_delta += MIDGAME_VALUE[Piece::Pawn as usize][to_opposite_idx];
        eg_delta += ENDGAME_VALUE[Piece::Pawn as usize][to_opposite_idx];
    }

    if board.is_move_castle(m) {
        let is_queen_castle = to_sq.file() == 2;
        let (rook_from_idx, rook_to_idx) = match is_queen_castle {
            true => (Square::A1 as usize, Square::D1 as usize),
            false => (Square::H1 as usize, Square::F1 as usize),
        };

        mg_delta += MIDGAME_VALUE[Piece::Rook as usize][rook_to_idx]
            - MIDGAME_VALUE[Piece::Rook as usize][rook_from_idx];
        eg_delta += ENDGAME_VALUE[Piece::Rook as usize][rook_to_idx]
            - ENDGAME_VALUE[Piece::Rook as usize][rook_from_idx];
    }

    (mg_delta, eg_delta)
}

/// A function used for ergonomics to convert from a table of millipawn values
/// to a table of `Eval`s.
const fn expand_table(centi_table: CentiPst) -> Pst {
    let mut table = [[Eval::DRAW; 64]; Piece::NUM_TYPES];
    let mut piece_idx = 0;
    // I would use for-loops here, but those are unsupported in const fns.
    while piece_idx < Piece::NUM_TYPES {
        let mut sq_idx = 0;
        while sq_idx < 64 {
            table[piece_idx][sq_idx] = Eval::centipawns(centi_table[piece_idx][sq_idx]);
            sq_idx += 1;
        }
        piece_idx += 1;
    }
    table
}

/* For now, we use the values from Stockfish. */

/// A PST for the value of pawns in the middlegame.
const MIDGAME_VALUE: Pst = expand_table([
    [
        // pawns. ranks 1 and 8 are inconsequential
        0, 0, 0, 0, 0, 0, 0, 0, // rank 1
        2, 4, 11, 18, 16, 21, 9, -3, // rank 2
        -9, -15, 11, 15, 31, 23, 6, -20, // rank 3
        -3, -20, 8, 30, 50, 17, 2, -5, // rank 4
        11, -4, -11, 2, 11, 0, -12, 5, // rank 5
        3, -11, -6, 22, -8, -5, -14, -11, // rank 6
        -7, 6, -2, -11, 4, -14, 1, -9, // rank 7
        0, 0, 0, 0, 0, 0, 0, 0, // rank 8
    ],
    [
        // knights
        -175, -92, -74, -73, -73, -74, -92, -175, // rank 1
        -77, -41, -27, -15, -15, -27, -41, -77, // rank 2
        -61, -17, 6, 12, 12, 6, -17, -61, // rank 3
        -35, 8, 40, 49, 49, 40, 8, -35, // rank 4
        -34, 13, 44, 51, 51, 44, 13, -34, // rank 5
        -9, 33, 58, 53, 53, 58, 33, -9, // rank 6
        -67, -27, 4, 37, 37, 4, -27, -67, // rank 7
        -201, -83, -56, -26, -26, -56, -83, -201, // rank 8
    ],
    [
        // bishops
        -37, -4, -6, -16, -16, -6, -4, -37, // rank 1
        -11, 6, 13, 3, 3, 13, 6, -11, // rank 2
        -5, 15, -4, 12, 12, -4, 15, -5, // rank 3
        -4, 8, 18, 27, 27, 18, 8, -4, // rank 4
        -8, 20, 5, 22, 22, 5, 20, -8, // rank 5
        -11, 4, 1, 8, 8, 1, 4, -11, // rank 6
        -12, -10, 4, 0, 0, 4, -10, -12, // rank 7
        -34, -1, -1, -16, -16, -1, -1, -34, // rank 8
    ],
    [
        // rooks
        -31, -20, -14, -5, -5, -14, -20, -31, // rank 1
        -21, -13, -8, 6, 6, -8, -13, -21, // rank 2
        -25, -11, -1, 3, 3, -1, -11, -25, // rank 3
        -13, -5, -4, -6, -6, -4, -5, -13, // rank 4
        -27, -15, -4, 3, 3, -4, -15, -27, // rank 5
        -22, -2, 6, 12, 12, 6, -2, -22, // rank 6
        -2, 12, 16, 18, 18, 16, 12, -2, // rank 7
        -17, -19, -1, 9, 9, -1, -19, -17, // rank 8
    ],
    [
        // queens
        3, -5, -5, 4, 4, -5, -5, 3, // rank 1
        -3, 5, 8, 12, 12, 8, 5, -3, // rank 2
        -3, 6, 13, 7, 7, 13, 6, -3, // rank 3
        4, 5, 9, 8, 8, 9, 5, 4, // rank 4
        0, 14, 12, 5, 5, 12, 14, 0, // rank 5
        -4, 10, 6, 8, 8, 6, 10, -4, // rank 6
        -5, 6, 10, 8, 8, 10, 6, -5, // rank 7
        -2, -2, 1, -2, -2, 1, -2, -2, // rank 8
    ],
    [
        // kings
        271, 327, 271, 198, 198, 271, 327, 271, // rank 1
        278, 303, 234, 179, 179, 234, 303, 278, // rank 2
        195, 258, 169, 120, 120, 169, 258, 195, // rank 3
        164, 190, 138, 98, 98, 138, 190, 164, // rank 4
        154, 179, 105, 70, 70, 105, 179, 154, // rank 5
        123, 145, 81, 31, 31, 81, 145, 123, // rank 6
        88, 120, 65, 33, 33, 65, 120, 88, // rank 7
        59, 89, 45, -1, -1, 45, 89, 59, // rank 8
    ],
]);

/// The PST for pieces in the endgame.
const ENDGAME_VALUE: Pst = expand_table([
    /* TODO update everything except kings */
    [
        // pawns. ranks 1 and 8 are inconsequential
        0, 0, 0, 0, 0, 0, 0, 0, // rank 1
        2, 4, 11, 18, 16, 21, 9, -3, // rank 2
        -9, -15, 11, 15, 31, 23, 6, -20, // rank 3
        -3, -20, 8, 19, 39, 17, 2, -5, // rank 4
        11, -4, -11, 2, 11, 0, -12, 5, // rank 5
        3, -11, -6, 22, -8, -5, -14, -11, // rank 6
        -7, 6, -2, -11, 4, -14, 1, -9, // rank 7
        0, 0, 0, 0, 0, 0, 0, 0, // rank 8
    ],
    [
        // knights
        -175, -92, -74, -73, -73, -74, -92, -175, // rank 1
        -77, -41, -27, -15, -15, -27, -41, -77, // rank 2
        -61, -17, 6, 12, 12, 6, -17, -61, // rank 3
        -35, 8, 40, 49, 49, 40, 8, -35, // rank 4
        -34, 13, 44, 51, 51, 44, 13, -34, // rank 5
        -9, 33, 58, 53, 53, 58, 33, -9, // rank 6
        -67, -27, 4, 37, 37, 4, -27, -67, // rank 7
        -201, -83, -56, -26, -26, -56, -83, -201, // rank 8
    ],
    [
        // bishops
        -37, -4, -6, -16, -16, -6, -4, -37, // rank 1
        -11, 6, 13, 3, 3, 13, 6, -11, // rank 2
        -5, 15, -4, 12, 12, -4, 15, -5, // rank 3
        -4, 8, 18, 27, 27, 18, 8, -4, // rank 4
        -8, 20, 5, 22, 22, 5, 20, -8, // rank 5
        -11, 4, 1, 8, 8, 1, 4, -11, // rank 6
        -12, -10, 4, 0, 0, 4, -10, -12, // rank 7
        -34, -1, -1, -16, -16, -1, -1, -34, // rank 8
    ],
    [
        // rooks
        -31, -20, -14, -5, -5, -14, -20, -31, // rank 1
        -21, -13, -8, 6, 6, -8, -13, -21, // rank 2
        -25, -11, -1, 3, 3, -1, -11, -25, // rank 3
        -13, -5, -4, -6, -6, -4, -5, -13, // rank 4
        -27, -15, -4, 3, 3, -4, -15, -27, // rank 5
        -22, -2, 6, 12, 12, 6, -2, -22, // rank 6
        -2, 12, 16, 18, 18, 16, 12, -2, // rank 7
        -17, -19, -1, 9, 9, -1, -19, -17, // rank 8
    ],
    [
        // queens
        3, -5, -5, 4, 4, -5, -5, 3, // rank 1
        -3, 5, 8, 12, 12, 8, 5, -3, // rank 2
        -3, 6, 13, 7, 7, 13, 6, -3, // rank 3
        4, 5, 9, 8, 8, 9, 5, 4, // rank 4
        0, 14, 12, 5, 5, 12, 14, 0, // rank 5
        -4, 10, 6, 8, 8, 6, 10, -4, // rank 6
        -5, 6, 10, 8, 8, 10, 6, -5, // rank 7
        -2, -2, 1, -2, -2, 1, -2, -2, // rank 8
    ],
    [
        // kings
        1, 45, 85, 76, 76, 85, 45, 1, // rank 1
        53, 100, 133, 135, 135, 133, 100, 53, // rank 2
        88, 130, 169, 175, 175, 169, 130, 88, // rank 3
        103, 156, 172, 172, 172, 172, 156, 103, // rank 4
        96, 166, 199, 199, 199, 199, 166, 96, // rank 5
        92, 172, 184, 191, 191, 184, 172, 92, // rank 6
        47, 121, 116, 131, 131, 116, 121, 47, // rank 7
        11, 59, 73, 78, 78, 73, 59, 11, // rank 8
    ],
]);

#[cfg(test)]
mod tests {

    use super::*;
    use crate::base::movegen::get_moves;
    use crate::base::Bitboard;
    use crate::base::Position;
    use crate::base::Square;
    use crate::fens::FRIED_LIVER_FEN;

    #[test]
    /// Test that the PST value of the pieces has left-right symmetry.
    fn test_left_right_symmetry() {
        for pt in Piece::NON_PAWN_TYPES {
            for sq1 in Bitboard::ALL {
                let sq2 = Square::new(sq1.rank(), 7 - sq1.file()).unwrap();
                assert_eq!(
                    MIDGAME_VALUE[pt as usize][sq1 as usize],
                    MIDGAME_VALUE[pt as usize][sq2 as usize]
                );
                assert_eq!(
                    ENDGAME_VALUE[pt as usize][sq1 as usize],
                    ENDGAME_VALUE[pt as usize][sq2 as usize]
                );
            }
        }
    }

    #[test]
    /// Test that adding deltas matches the same result as taking the PST value
    /// from scratch.
    fn test_pst_delta_equals_base_result() {
        let pos = Position::from_fen(FRIED_LIVER_FEN, Position::no_eval).unwrap();
        let pst_original = pst_evaluate(&pos.board);

        for m in get_moves(&pos) {
            let delta = pst_delta(&pos.board, m);
            let delta_eval = (pst_original.0 + delta.0, pst_original.1 + delta.1);
            let mut bcopy = pos.board;
            bcopy.make_move(m);
            assert_eq!(delta_eval, pst_evaluate(&bcopy));
        }
    }
}
